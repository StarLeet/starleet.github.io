{"meta":{"title":"starlee","subtitle":"starleeの博客","description":"烈日升而星不落","author":"starlee","url":"https://starleet.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2021-09-27T09:05:45.467Z","comments":true,"path":"about/index.html","permalink":"https://starleet.github.io/about/index.html","excerpt":"","text":"待补充~"},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://starleet.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://starleet.github.io/music/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://starleet.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-08-14T07:44:13.518Z","comments":false,"path":"comments/index.html","permalink":"https://starleet.github.io/comments/index.html","excerpt":"","text":"new Artitalk({ appId: 'o2lydQokojD1IP8EGhex24WU-MdYXbMMI', appKey: '8ykSyPm9CwzCDdR5dbid1AWT' })"},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://starleet.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://starleet.github.io/link/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-09-27T08:29:39.677Z","updated":"2021-08-14T10:54:08.719Z","comments":false,"path":"List/gallery/index.html","permalink":"https://starleet.github.io/List/gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://starleet.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"https://starleet.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-27T08:29:39.681Z","updated":"2021-08-14T10:51:08.180Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://starleet.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-24T08:05:01.000Z","updated":"2021-08-13T06:23:02.212Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://starleet.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""}],"posts":[{"title":"example","slug":"test","date":"2021-09-20T08:56:04.000Z","updated":"2021-09-26T22:51:44.331Z","comments":true,"path":"posts/6eec9b9f.html","link":"","permalink":"https://starleet.github.io/posts/6eec9b9f.html","excerpt":"","text":"[TOC] 什么是git git是一个版本控制的工具 git可以记录若干文件的变化,以便将来查阅特定版本修订情况的系统。简而言之,就是==备份与记录== 版本控制 比如:我开发了一个软件第一次修订 修改了第10行的内容 保存为release 1.0第二次修订 修改了第20行的内容 保存为release 2.0第三次修订 修改了非常多的内容 保存为release 3.0然后经过后续使用,我发现第三次修订的软件中有大量未显现的bug,但是无法在复原到第二次修订时的现场。为避免此类情况,我们可以使用git进行版本控制,退回2.0甚至是1.0版本 ==Git的版本控制其实就是一种不断增量的行为==。版本的从release 1.0 ——&gt; release 2.0不是完全的copy而是只保留了修改的、新添的部分。比如上图。所以日志的完整性显得尤为重要,这就是为什么我们要时常pull代码,同步远端与本地的日志。(否则本地日志与远程仓库出现断层,就会push失败,如下图) 上图模拟了两个人做开发。本来二者都是处在第一版提交的进度,但是 左边的开发者Apush了一个新版本‘仓库1的提交’ 之后右边的开发者B commit了一个新版本‘仓库2的提交’,但是它没有pull新代码,导致了它与远程仓库间缺失了一个‘仓库1的提交’的日志 所以当B想push代码时,报了错误,git认为这是两个仓库的东西,因为日志不一致,有断层 解决方式:pull代码,有冲突解决冲突 分布式版本控制 在分布式版本控制中:代码仓库不仅仅存储在远端仓库(github等),而且还会在本地计算机做一份最新文件的拷贝 Git官方文档:像 Git、Mercurial、Bazaar 以及 Darcs 等,客户端并不只提取最新版本的文件快照,而是把代码仓库完整地镜像下来，包括完整的历史记录.这么一来，任何一处协同工作用的服务器发生故障,事后都可以用任何一个镜像出来的本地仓库恢复.因为每一次的克隆操作,实际上都是一次对代码仓库的完整备份。 git配置操作 git config --global user.name \"your_username\" git config --global user.email your_email@domain.com git config --list #查看之前的所有配置 git的文件状态 状态 描述 已提交(committed) 数据已经安全地保存在本地仓库中 已修改(modified) 修改了文件,但还没保存到仓库中 已暂存(staged) 对一个已修改的当前版本做标记,使之包含在下次提交的快照中 git的三个区域 分类 描述 工作区 电脑里能看到的目录,比如自己创建的项目文件夹(Codefield) 暂存区 ==Git版本库中最重要的区域==,称为stage。里边有Git自动创建的第一个分支master,以及指向master的一个HEAD指针 Git仓库 工作区中的一个隐藏目录.git, 这个不是工作区,而是==Git的版本库== 暂存区(缓存区):英文叫stage,或index。一般存放在”.git目录下”下的index文件(.git/index)中,所以我们把暂存区有时也叫作索引(index)。它实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息(时间戳、文件长度等),文件的内容并不存储其中，而是保存在Git对象库(.git/objects)中，文件索引建立了文件和对象库中对象实体之间的对应。如果当前仓库，有文件更新，并且使用git add命令，那么这些更新就会出现在暂存区中。 版本库:工作区有一个隐藏目录.git,这个不算工作区,而是Git的版本库。git中的refs/heads/master是分支，是版本库。 图中的objects标识的区域为Git的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached ” 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout – ” 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 git工作流程 在工作区中修改某些文件 对修改后的文件进行快照,然后添加到缓存区 提交更新,将保存在暂存区的文件快照永久转储到Git仓库(本地仓库)中 git指令的使用init_版本库初始化 版本库又名本地仓库,可以理解为一个简单的目录,这个目录里的所有文件都可以被Git所管理。每个文件的修改、删除、Git都可以跟踪,以便任何时刻都可以追踪历史,或者在某时刻还原。 进入指定目录,或者在指定目录打开git bash 输入指令git init 至此文件夹下出现一个.git隐藏文件夹,版本库创建完成 add_添加文件到暂存区 git add 指定文件名 将文件纳入版本控制中git add . 将当前所有的文件纳入版本控制(常用) git add有追踪文件的意思,从来没有使用过git add的文件,在使用git status查看状态时,提示的是untracked ==注意:只有先add之后,commit的指令才生效== status_查看文件情况 git status 前面总览 commit_提交文件 git commit -m '版本说明' commit指令是将文件从暂存区提交到本地仓库,此时才算是版本发布完成 log_查看版本日志 git log查看详细提交日志 git log -p 显示日志,并显示每次提交的差异 git log --stat -p信息的简洁版 git log -5 --pretty=oneline日志在一行简短显示,且只显示最新5条 git log --graph --oneline以==点线图==形式显示日志,且哈希值简短显示 ls-files查看仓库文件 git ls-files可以查看本地仓库里的文件,可用来确认文件是否提交成功 diff_文件变动比较 git diff HEAD -- 文件A 该指令的含义是,比较《工作区文件A的内容》与《本地仓库中文件A的内容》 差异比较说明:(比较的是上一次commit的文件与现在修改的文件,然后标出变动的内容) ---:表示变动前的文件+++:表示变动后的文件变动的位置用两个@作为起始和结束 @@ -1,5 +1,5 @@ :”-1,5”减号表示变动前的文件,从第一行到往后的5行结束。同样的,”+1,5”表示变动后,从第一行到往后的5行结束。说明没有删除某一行 补充:上图中就表示了,原文件变动内容往后有6行,修改后只剩5行了,说明被删掉了一行看图中可见,第3行的w w w被改成了w1w1w1,第六行的11111被删掉了 如果用git diff的时候看到^M字符，就说明两个文件在换行符上有所差别 Windows用CRLF来定义换行,Linux用LF。CR全称是Carriage Return,或者表示为\\r, 意思是回车。LF全称是Line Feed,它才是真正意义上的换行表示符。 下面简单的方法可以让git diff的时候忽略换行符的差异: git config --global core.whitespace cr-at-eol ==reset_版本切换== git reset 简而言之,git reset是用来将当前branch重置到另外一个commit的,这个动作可能同时影响到index以及work directory 先举个例子，来一个感性的认识。 git checkout hotfix git reset HEAD~2 #hotfix 分支向后回退两个提交 # git reset HEAD^^ 可以达到类似效果 hotfix分支末端的两个提交现在变成了孤儿提交。下次==Git执行垃圾回收==的时候,这两个提交会被删除。如果你的提交还没有共享给别人,可以用git reset撤销这些提交。 git的三棵树 理解reset(以后还要说checkout)的最简方法,就是以Git的思维框架(将其作为内容管理器)来管理三棵不同的树。“树”在我们这里的实际意思是“文件集合”,而不是指特定的数据结构。 Git作为一个系统,是以它的一般操作来管理并操纵这三棵树的: 树 用途 HEAD 上一次提交的快照,下一次提交的父节点 Index 预期的下一次提交快照 Working Directory 沙盒 HEADHEAD是当前分支引用的指针,它总是指向该分支上的最后一次提交。这表示HEAD将是下一次提交的父结点。通常,可以把HEAD看做你的上一次提交的快照。 索引(Index)索引是你预期的下一次提交。这就是当你运行git commit时Git看起来的样子。Git将上一次检出到工作目录中的所有文件填充到索引(暂存区),之后你会将其中一些文件替换为新版本,接着通过git commit将它们转换为树来用作新提交。 工作目录另外两棵树以一种高效但并不直观的方式,将它们的内容存储在.git文件夹中。工作目录会将它们解包为实际的文件以便编辑。你可以把工作目录当做“沙盒”,在你将修改提交到暂存区并记录到历史之前,可以随意更改。 ==reset流程图解== git reset [--soft | --mixed | --hard] [版本号 | HEAD~n] git reset –soft [版本号|HEAD~n]只回滚提交点,暂存区和工作目录内容不改变 git reset –mixed [版本号|HEAD~n] git默认方式回滚提交点和暂存区的内容,工作区内容不变 git reset –hard [版本号|HEAD~n]提交点、暂存区、工作区全部回滚 **注意1:HEAD~ HEAD HEAD~1 三者都是等价的,都特指前一个版本 HEAD~n n为几,向前回滚几个版本** 注意2:–hard标记是reset命令==唯一的危险用法==,它也是Git会真正地销毁数据的仅有的几个操作之一。其他任何形式的reset调用都可以轻松撤消,但是–hard选项不能,因为它强制覆盖了工作目录中的文件。 git reset 另一种用法,后接文件或目录 恢复索引中的文件到某个版本 假设版本库中是文件file.txt的V1版本,HEAD、Index和工作目录都和版本库一致。这时候修改了file.txt文件,并把它(V2版本)加入Index。如下图所示：现在,运行git reset file.txt(这其实是git reset --mixed HEAD file.txt的简写形式),它会让索引看起来像HEAD,所以它本质上只是将file.txt从HEAD复制到索引中。如下图：仔细对比这两幅图,你会发现git reset file.txt有“取消暂存文件”的实际效果。它和git add所做的事相反。这就是为什么git status命令的输出会建议运行此命令来取消暂存一个文件。例如： 另外,我们可以不让Git从HEAD拉取数据,而是通过具体指定一个提交来拉取该文件的对应版本。我们只需运行类似于git reset eb43bf file.txt的命令即可。依然用图来说明：以上是版本库、Index和工作目录的状态。现在,执行git reset eb43 file.txt 压缩提交 假设你有一个项目,第一次提交中增加了文件a,第二次提交增加了一个新的文件b并修改了a,第三次提交再次修改了a。那么显然第三次的修改a可以并入第二次的修改a,因为它俩完全是做的一样的事情。 首先,运行git reset --soft HEAD~2将HEAD分支移动到一个旧一点的提交上(即回滚到第一次的提交): 然后commit现在你可以查看可到达的历史,即将会推送的历史,现在看起来有个v1版file-a.txt的提交,接着第二个提交将file-a.txt修改成了v3版并增加了file-b.txt。包含v2版本的文件已经不在历史中了。 ==reflog_总日志查询==有的时候我们使用git reset --hard回退到前几个版本查看日志,哎后几个版本的日志没了？该怎么办？使用git reflog查询commit记录!这样就可以回退回去了,回退之后使用git log版本日志就回来了 远程仓库Git生成ssh密钥 使用SSH加密方式是Git建议的一种推送,时间上与响应上效率都更高 空白处右键点击Git bath生成SSH公钥与私钥ssh-keygen -t rsa -C \"github账户邮箱\"然后一路回车确定 密钥保存路径要默认 密钥自己留着,公钥可以填GitHub里 在GitHub中配置完后,可以在bath里输入ssh -T git@github.com,有successful就成功了 clone_克隆操作 第一次拉取本地用git clone,后续更新直接用git pull 在指定目录下创建一个子目录,进入其中打开bash,输入git clone github_ssh==注意:克隆下来的是所有的内容包括分支,只不过它不显示,但是可以直接切换到分支。而且git clone默认实现了本工作区对远程仓库的绑定,后续使用无需再进行绑定了。== Push_推送仓库 在GitHub上创建一个仓库(已有可省略) echo \"# git_test\" &gt;&gt; README.md #添加阅读信息(可省略) git init #初始化本地仓库,已在本地初始化后可不做 git add README.md #添加阅读信息至暂存区(选做) git commit -m \"first commit\" #第一次提交本地仓库 git branch -M main #改名当前分支为main git remote add origin git@github.com:StarLeet/git_test.git #本地库绑定远程仓库 并取名origin git push -u origin main #进行推送 #-u 表示默认设定提交到origin的main中 #后续可以直接git push(保持默认) 或者 git push origin 分支名 在第一次push的时候会让你登陆github账户 重定远程仓库如果说前边你已经绑定了一个仓库现在想删除它 工作区打开bash vim .git/config /直接用文本编辑器也可以 直接删除即可 branch_分支操作 多人开发时通常不会直接在主干master上进行操作,而是重新开辟新的分支,在新的分支上进行开发调试操作,当项目调试通过时才会将分支的项目代码合并到主干中。主干与分支的关系:犹如原件与副本的关系,副本上出现了问题可以随时丢弃。分支上的变化也不会影响到主干,除非你合并分支 命令 含义 git branch 查看本地所有的分支(* 代表当前所在分支) git ls-files 查看本地仓库的所有文件 git checkout 分支名 切换分支 git checkout -b 新分支名 新建一个分支,并切换过去 git merge 分支名(可以是主干) 将输入分支合并到此分支 git branch -d|D 分支名 删除/强制删除指定分支 git branch -m | -M 旧分支名 新分支名 分支重命名,-M是强制重命名 标准工作流 分支的push与pull操作 命令 含义 git branch -a 查看本地与远程的分支 git push origin 分支名 将分支推到远端 git push origin :分支名 删除远端的分支 git checkout -b 新命名 origin/远端分支名 拉取远端分支到本地 本地分支冲突 当我们在进行分支操作时,可能会出现这样的情况:master主干上:test1.txt 第六行是1231 leaf01分支上:test1.txt 第六行是010这里进行主干合并leaf01分支时,会产生内容不一致而失败的问题。最主要原因是因为主干与分支的相同行内容不合。这个称为分支冲突 多人协同冲突 多个本地仓库向github上传的内容不一样会导致典型报错信息: 解决方式:push前先从远端拉取一下内容git pull,这样可以解决80%的冲突 tag标签管理 命令 含义 git tag 查看所有标签 git tag 标签名 新建本地标签 默认为HEAD git tag -a 标签名 -m ‘描述信息’ -a表示有标签,新建本地标签并指定描述信息 git tag -d 标签名 删除一个本地标签 git push origin 标签名 推送一个本地标签到远端 git push origin –tags 推送所有本地标签 git push origin :refs/tags/标签名 删除一个远端标签 补充:工作流程公司新上任拉取代码 git clone 远程仓库地址 (自带git remote add origin 仓库DNS域名) git checkout 分支 (切换分支) git clone一般仅操作一次,后续用的pull,只拉取变动的提交 在公司开发 git checkout dev (切换到开发分支) git merge master(把主干并入分支dev 仅一次) 修改代码 提交代码 git add . git commit -m ‘说明’ git push origin dev 回到家中继续写代码 git checkout dev 拉取代码 git pull origin dev 继续开发,相同的提交步骤 rebase(变基)变基的作用:使Git记录变得简洁,即合并几次提交记录 #方式一 git rebase -i 版本号 #表示合并从该版本号到目前版本的记录 #方式二 git rebase -i HEAD~3 #表示合并最近三次的提交记录 注意:尽量不要合并push到远程仓库的记录 使用情景一: 切换到支线dev git checkout dev 在分支上提交新的记录 git commit -m 'xxx' 把刚才提交的记录变基到主干 git rebase master 切换到master git checkout master 合并分支dev git merge dev 如此操作下来,合并的日志将不在有分叉,而是直接跟主干的日志是一样的 使用场景二: 如果说你想让支线日志归并到主线而不产生分叉:C1&lt;——C2&lt;——C3&lt;——C4 我们将代码从远端仓库拉回本地的时候,如果发生冲突是会产生分叉的日志。要想不产生分叉日志,使其更加地简洁。我们就不能再使用pull(fetch + merge) git fetch origin dev git rebase origin/dev rebase碰上冲突 如果我们使用git rebase碰上了冲突,解决方式是: 手动解决冲突区块 根据提示执行git add . git rebase --continue ==前面总结== 绑定远程仓库 git remote add origin 链接 推送到远程仓库 git push origin 分支名 下载代码 git clone 链接 拉取代码 git pull origin 分支名 &lt;=&gt; git fetch origin 分支名 **git merge origin 分支名** 保持代码提交简洁(变基) git rebase 分支名 log日志图形展示 git log –graph [–pretty=format:“%h %s”] 多人协同开发gitflow 从主干上开辟dev分支(开发部门总项目人把关),从dev分支再开辟各小组分支;在自己分支上做完开发后,由总项目人确定无误后,合并到dev分支上同时开辟的新的分支release(用于测试并修复bug),无误后合并到master主干。 tag标签用法git tag -a 标签名 -m '描述信息' 给当前提交的(HEAD指针所指的)日志打上标签,比如:release1.0 打完标签后,推送到远程仓库(github):git push origin --tags tag相当于是给日志那个冗长的hash值取了个昵称 给开源项目贡献代码 fork源代码:将别人源代码拷贝到我自己的远程仓库 pull拉取代码到本地进行二次开发 push到远程仓库 给源代码作者提交 修复bug的申请(pull request) .gitignore文件如果有不需要git管理跟踪的文件,可以加在.gitignore文件中","categories":[],"tags":[]},{"title":"first article","slug":"first-article","date":"2021-09-14T08:26:36.000Z","updated":"2021-09-26T22:54:42.019Z","comments":true,"path":"posts/64c6e1a6.html","link":"","permalink":"https://starleet.github.io/posts/64c6e1a6.html","excerpt":"","text":"下边是java噢~ public class Client01 { public static void main(String[] args) throws IOException { //1.客户端直接实例化一个Socket Socket socket = new Socket(InetAddress.getLocalHost(),9999); System.out.println(\"客户端 socket返回 =\" + socket.getClass()); OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"hello world\".getBytes()); socket.shutdownOutput(); //设置结束标记 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int readLen = 0; while((readLen = inputStream.read(buf)) != -1){ System.out.println(new String(buf,0,readLen)); } outputStream.close(); inputStream.close(); socket.close(); System.out.println(\"客户端退出\"); } } git clone xxxxx git reset --hard HEAD~n Class Cat{ private int a; private String name Cat(int a , String name){ this.a = a; this.name = name; } public void test(){ Syetem.out.println(\"==========\"); } } #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;stdlib.h&gt; #include &lt;time.h&gt; #ifndef _CLOCK_T_DEFINED typedef long clock_t; #define _CLOCK_T_DEFINED #endif typedef int ElementType; // 定义数据类型,可根据需要进行其他类型定义 typedef struct ListNode { ElementType Element; // 数据域，存放数据 struct ListNode* Next; // 指向下一个链表节点 }Node,*List; //List ~ Node * void InitList(Node* *phead ){ *phead = (Node *)malloc(sizeof(Node)); if(*phead == NULL){ printf(\"头节点分配失败!\"); exit(-1); } (*phead)-&gt;Next = NULL; } void AddItemInHead(List pHead,int val,Node * *tail){ List pNew = (Node *)malloc(sizeof(Node)); //生成新节点 if(pNew == NULL){ printf(\"新节点分配失败，程序终止！ \\n\"); exit(-1); } pNew-&gt;Element=val; pNew-&gt;Next = NULL; if(pHead-&gt;Next == NULL){ pHead-&gt;Next = pNew; }else{ (*tail)-&gt;Next = pNew; } *tail = pNew; } void AddItemInTail(int val,List *tail){ List pNew = (Node *)malloc(sizeof(Node)); //生成新节点 if(pNew == NULL){ printf(\"新节点分配失败，程序终止！ \\n\"); exit(-1); } pNew-&gt;Element=val; pNew-&gt;Next = NULL; (*tail)-&gt;Next = pNew; *tail = pNew; } void Showlist(List pHead){ printf(\"%p\\n\",pHead); pHead=pHead-&gt;Next; //跳过头结点输出 while(pHead!=NULL){ printf(\"%d \",pHead-&gt;Element); pHead=pHead-&gt;Next; } } // 主函数 int main() { Node* L; Node * tail; InitList(&amp;L); clock_t start,finish; double totaltime; start=clock(); int i; for(i = 0;i&lt;100;i++ ){ AddItemInHead(L,i,&amp;tail); } AddItemInTail(100000,&amp;tail); finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; printf(\"\\n向链表添加数据时间为%f秒！\\n\",totaltime); start=clock(); for(i = 0;i&lt;100000;i++ ){ AddItemInTail(10000000,&amp;tail); } //Showlist(L); finish=clock(); totaltime=(double)(finish-start)/CLOCKS_PER_SEC; printf(\"\\n输出数据时间为%f秒！\\n\",totaltime); return 0; }","categories":[],"tags":[]},{"title":"Markdown快速入门小技巧(hexo博客文章--格式用法)","slug":"03-Markdown快速入门小技巧","date":"2021-06-21T08:00:00.000Z","updated":"2021-07-28T11:01:26.837Z","comments":true,"path":"posts/15546.html","link":"","permalink":"https://starleet.github.io/posts/15546.html","excerpt":"","text":"相遇皆是缘分 Markdown 的快速入门(后缀是 .md)快捷键ctrl+shift+1 大纲显示 ctrl+/ 源代码显示 代码块：​```java(html等等) 会自动提示 标题#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 加粗//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 作者：泽 作者：泽 作者：泽 分割线//分割线 --- *** 图片插入//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接//超链接语法 [超链接名字]（https://gihub.com/yerenping） 我的天空 列表//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格右键》插入》表格 用代码过于复杂不推荐使用 姓名 数字 语文 小王 85 21","categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://starleet.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"hexo博客/Markdown","permalink":"https://starleet.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/Markdown/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://starleet.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"Markdown","permalink":"https://starleet.github.io/tags/Markdown/"}]}],"categories":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://starleet.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"hexo博客/Markdown","permalink":"https://starleet.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/Markdown/"}],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"https://starleet.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Markdown","slug":"Markdown","permalink":"https://starleet.github.io/tags/Markdown/"}]}