<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>example</title>
      <link href="/posts/6eec9b9f.html"/>
      <url>/posts/6eec9b9f.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git"></a>什么是git</h1><ul><li><strong>git是一个版本控制的工具</strong></li></ul><blockquote><p><strong>git可以记录若干文件的变化,以便将来查阅特定版本修订情况的系统。简而言之,就是==备份与记录==</strong></p></blockquote><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><blockquote><p><strong>比如:我开发了一个软件</strong><br><strong>第一次修订    修改了第10行的内容    保存为release 1.0</strong><br><strong>第二次修订    修改了第20行的内容    保存为release 2.0</strong><br><strong>第三次修订    修改了非常多的内容     保存为release 3.0</strong><br><strong>然后经过后续使用,我发现第三次修订的软件中有大量未显现的bug,但是无法在复原到第二次修订时的现场。为避免此类情况,我们可以使用git进行版本控制,退回2.0甚至是1.0版本</strong><br><img src="E:\markdown文件\photoes\image-20210911050551705.png" alt="image-20210911050551705"></p></blockquote><p><strong>==Git的版本控制其实就是一种不断增量的行为==。版本的从release 1.0 ——&gt; release 2.0不是完全的copy而是只保留了修改的、新添的部分。比如上图。所以日志的完整性显得尤为重要,这就是为什么我们要时常pull代码,同步远端与本地的日志。(否则本地日志与远程仓库出现断层,就会push失败,如下图)</strong><br><img src="E:\markdown文件\photoes\image-20210917095618040.png" alt="image-20210917095618040"></p><blockquote><p><strong>上图模拟了两个人做开发。</strong><br><strong>本来二者都是处在第一版提交的进度,但是</strong></p><ol><li><strong>左边的开发者Apush了一个新版本‘仓库1的提交’</strong></li><li><strong>之后右边的开发者B commit了一个新版本‘仓库2的提交’,但是它没有pull新代码,导致了它与远程仓库间缺失了一个‘仓库1的提交’的日志</strong></li><li><strong>所以当B想push代码时,报了错误,git认为这是两个仓库的东西,因为日志不一致,有断层</strong></li></ol><p><strong>解决方式:pull代码,有冲突解决冲突</strong></p></blockquote><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p><img src="E:\markdown文件\photoes\image-20210904025409712.png" alt="image-20210904025409712"></p><blockquote><p><strong>在分布式版本控制中:</strong><br><strong>代码仓库不仅仅存储在远端仓库(github等),而且还会在本地计算机做一份最新文件的拷贝</strong></p><p><strong>Git官方文档:</strong><br><strong>像 Git、Mercurial、Bazaar 以及 Darcs 等,客户端并不只提取最新版本的文件快照,而是把代码仓库完整地镜像下来，包括完整的历史记录.这么一来，任何一处协同工作用的服务器发生故障,事后都可以用任何一个镜像出来的本地仓库恢复.因为每一次的克隆操作,实际上都是一次对代码仓库的完整备份。</strong></p></blockquote><h1 id="git配置操作"><a href="#git配置操作" class="headerlink" title="git配置操作"></a>git配置操作</h1>   <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global user.name <span class="token string">"your_username"</span><span class="token function">git</span> config --global user.email your_email@domain.com<span class="token function">git</span> config --list  <span class="token comment">#查看之前的所有配置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="git的文件状态"><a href="#git的文件状态" class="headerlink" title="git的文件状态"></a>git的文件状态</h1><table><thead><tr><th align="center">状态</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>已提交(committed)</strong></td><td align="center"><strong>数据已经安全地保存在本地仓库中</strong></td></tr><tr><td align="center"><strong>已修改(modified)</strong></td><td align="center"><strong>修改了文件,但还没保存到仓库中</strong></td></tr><tr><td align="center"><strong>已暂存(staged)</strong></td><td align="center"><strong>对一个已修改的当前版本做标记,使之包含在下次提交的快照中</strong></td></tr></tbody></table><h1 id="git的三个区域"><a href="#git的三个区域" class="headerlink" title="git的三个区域"></a>git的三个区域</h1><table><thead><tr><th align="center">分类</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>工作区</strong></td><td align="center"><strong>电脑里能看到的目录,比如自己创建的项目文件夹(Codefield)</strong></td></tr><tr><td align="center"><strong>暂存区</strong></td><td align="center"><strong>==Git版本库中最重要的区域==,称为stage。里边有Git自动创建的第一个分支master,以及指向master的一个HEAD指针</strong></td></tr><tr><td align="center"><strong>Git仓库</strong></td><td align="center"><strong>工作区中的一个隐藏目录.git, 这个不是工作区,而是==Git的版本库==</strong></td></tr></tbody></table><p><img src="E:\markdown文件\photoes\image-20210917110556346.png" alt="image-20210917110556346"></p><ul><li><p><strong>暂存区(缓存区):英文叫stage,或index。一般存放在”.git目录下”下的index文件(.git/index)中,所以我们把暂存区有时也叫作索引(index)。它实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息(时间戳、文件长度等),文件的内容并不存储其中，而是保存在Git对象库(.git/objects)中，文件索引建立了文件和对象库中对象实体之间的对应。如果当前仓库，有文件更新，并且使用<code>git add</code>命令，那么这些更新就会出现在暂存区中。</strong></p></li><li><p><strong>版本库:工作区有一个隐藏目录.git,这个不算工作区,而是Git的版本库。git中的refs/heads/master是分支，是版本库。</strong></p></li></ul><blockquote><p><strong>图中的objects标识的区域为Git的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</strong></p><p><strong>当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</strong></p><p><strong>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</strong></p><p><strong>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</strong></p><p><strong>当执行 “git rm –cached ” 命令时，会直接从暂存区删除文件，工作区则不做出改变。</strong></p><p><strong>当执行 “git checkout .” 或者 “git checkout – ” 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</strong></p></blockquote><h1 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h1><ol><li><strong>在工作区中修改某些文件</strong></li><li><strong>对修改后的文件进行快照,然后添加到缓存区</strong></li><li><strong>提交更新,将保存在暂存区的文件快照永久转储到Git仓库(本地仓库)中</strong><br><img src="E:\markdown文件\photoes\image-20210904033534985.png" alt="image-20210904033534985"></li></ol><h1 id="git指令的使用"><a href="#git指令的使用" class="headerlink" title="git指令的使用"></a>git指令的使用</h1><h3 id="init-版本库初始化"><a href="#init-版本库初始化" class="headerlink" title="init_版本库初始化"></a>init_版本库初始化</h3><blockquote><p><strong>版本库又名本地仓库,可以理解为一个简单的目录,这个目录里的所有文件都可以被Git所管理。每个文件的修改、删除、Git都可以跟踪,以便任何时刻都可以追踪历史,或者在某时刻还原。</strong></p></blockquote><ol><li><strong>进入指定目录,或者在指定目录打开git bash</strong></li><li><strong>输入指令<code>git init</code></strong></li><li><strong>至此文件夹下出现一个.git隐藏文件夹,版本库创建完成</strong></li></ol><h3 id="add-添加文件到暂存区"><a href="#add-添加文件到暂存区" class="headerlink" title="add_添加文件到暂存区"></a>add_添加文件到暂存区</h3><ul><li><strong><code>git add 指定文件名</code> 将文件纳入版本控制中</strong><br><code>git add .</code> <strong>将当前所有的文件纳入版本控制(常用)</strong></li><li><strong><code>git add</code>有追踪文件的意思,从来没有使用过<code>git add</code>的文件,在使用<code>git status</code>查看状态时,提示的是untracked</strong></li></ul><p><strong>==注意:只有先add之后,commit的指令才生效==</strong></p><h3 id="status-查看文件情况"><a href="#status-查看文件情况" class="headerlink" title="status_查看文件情况"></a>status_查看文件情况</h3><ul><li><code>git status</code></li></ul><h2 id="前面总览"><a href="#前面总览" class="headerlink" title="前面总览"></a>前面总览</h2><p>   <img src="E:\markdown文件\photoes\image-20210904040450164.png" alt="image-20210904040450164"></p><h3 id="commit-提交文件"><a href="#commit-提交文件" class="headerlink" title="commit_提交文件"></a>commit_提交文件</h3><ul><li><p><code>git commit -m '版本说明'</code></p><p><strong>commit指令是将文件从暂存区提交到本地仓库,此时才算是版本发布完成</strong><br><img src="E:\markdown文件\photoes\image-20210904040750898.png" alt="image-20210904040750898"></p></li></ul><h3 id="log-查看版本日志"><a href="#log-查看版本日志" class="headerlink" title="log_查看版本日志"></a>log_查看版本日志</h3><ul><li><p><code>git log</code><strong>查看详细提交日志</strong></p><p><img src="E:\markdown文件\photoes\image-20210918112050813.png" alt="image-20210918112050813"></p></li><li><p><code>git log -p</code> <strong>显示日志,并显示每次提交的差异</strong></p></li><li><p><code>git log --stat</code> <strong>-p信息的简洁版</strong></p></li><li><p><code>git log -5 --pretty=oneline</code><strong>日志在一行简短显示,且只显示最新5条</strong><br><img src="E:\markdown文件\photoes\image-20210918112332321.png" alt="image-20210918112332321"></p></li><li><p><code>git log --graph --oneline</code><strong>以==点线图==形式显示日志,且哈希值简短显示</strong><br><img src="E:\markdown文件\photoes\image-20210918112558451.png" alt="image-20210918112558451"></p></li></ul><h3 id="ls-files查看仓库文件"><a href="#ls-files查看仓库文件" class="headerlink" title="ls-files查看仓库文件"></a>ls-files查看仓库文件</h3><ul><li><code>git ls-files</code><br><strong>可以查看本地仓库里的文件,可用来确认文件是否提交成功</strong></li></ul><h3 id="diff-文件变动比较"><a href="#diff-文件变动比较" class="headerlink" title="diff_文件变动比较"></a>diff_文件变动比较</h3><ul><li><p><code>git diff HEAD -- 文件A</code></p><p><strong>该指令的含义是,比较《工作区文件A的内容》与《本地仓库中文件A的内容》</strong><br><img src="E:\markdown文件\photoes\image-20210918114542677.png" alt="image-20210918114542677"></p></li></ul><blockquote><p><strong>差异比较说明:(比较的是上一次commit的文件与现在修改的文件,然后标出变动的内容)</strong></p><p><code>---</code><strong>:表示变动前的文件</strong><br><code>+++</code>:<strong>表示变动后的文件</strong><br><strong>变动的位置用两个@作为起始和结束</strong></p><p><strong>@@ -1,5 +1,5 @@ :”-1,5”减号表示变动前的文件,从第一行到往后的5行结束。同样的,”+1,5”表示变动后,从第一行到往后的5行结束。说明没有删除某一行</strong></p><blockquote><p><strong>补充:</strong><br><img src="E:\markdown文件\photoes\image-20210918115414263.png" alt="image-20210918115414263"><br><strong>上图中就表示了,原文件变动内容往后有6行,修改后只剩5行了,说明被删掉了一行</strong><br><strong>看图中可见,第3行的<code>w w w</code>被改成了<code>w1w1w1</code>,第六行的<code>11111</code>被删掉了</strong></p></blockquote><p><strong>如果用<code>git diff</code>的时候看到<code>^M</code>字符，就说明两个文件在换行符上有所差别</strong></p><blockquote><p><strong>Windows用CRLF来定义换行,Linux用LF。</strong><br><strong>CR全称是Carriage Return,或者表示为\r, 意思是回车。</strong><br><strong>LF全称是Line Feed,它才是真正意义上的换行表示符。</strong></p></blockquote><p><strong>下面简单的方法可以让git diff的时候忽略换行符的差异:</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global core.whitespace cr-at-eol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="reset-版本切换"><a href="#reset-版本切换" class="headerlink" title="==reset_版本切换=="></a>==reset_版本切换==</h3><ul><li><code>git reset</code></li></ul><blockquote><p><strong>简而言之,<code>git reset</code>是用来将当前branch重置到另外一个commit的,这个动作可能同时影响到index以及work directory</strong></p></blockquote><p><strong>先举个例子，来一个感性的认识。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout hotfix<span class="token function">git</span> reset HEAD~2 <span class="token comment">#hotfix 分支向后回退两个提交</span><span class="token comment"># git reset HEAD^^  可以达到类似效果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="E:\markdown文件\photoes\image-20210918173053977.png" alt="image-20210918173053977" style="zoom: 67%;"><img src="E:\markdown文件\photoes\image-20210918173434605.png" alt="image-20210918173434605" style="zoom: 67%;"><p><strong>hotfix分支末端的两个提交现在变成了孤儿提交。下次==Git执行垃圾回收==的时候,这两个提交会被删除。如果你的提交还没有共享给别人,可以用<code>git reset</code>撤销这些提交。</strong></p><h4 id="git的三棵树"><a href="#git的三棵树" class="headerlink" title="git的三棵树"></a>git的三棵树</h4><blockquote><p><strong>理解reset(以后还要说checkout)的最简方法,就是以Git的思维框架(将其作为内容管理器)来管理三棵不同的树。“树”在我们这里的实际意思是“文件集合”,而不是指特定的数据结构。</strong></p></blockquote><p><strong>Git作为一个系统,是以它的一般操作来管理并操纵这三棵树的:</strong></p><table><thead><tr><th align="center">树</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><strong>HEAD</strong></td><td align="center"><strong>上一次提交的快照,下一次提交的父节点</strong></td></tr><tr><td align="center"><strong>Index</strong></td><td align="center"><strong>预期的下一次提交快照</strong></td></tr><tr><td align="center"><strong>Working Directory</strong></td><td align="center"><strong>沙盒</strong></td></tr></tbody></table><h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><p><strong><code>HEAD</code>是当前分支引用的指针,它总是指向该分支上的最后一次提交。这表示<code>HEAD</code>将是下一次提交的父结点。通常,可以把<code>HEAD</code>看做你的上一次提交的快照。</strong><br><img src="E:\markdown文件\photoes\image-20210918180007257.png" alt="image-20210918180007257"></p><h5 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引(Index)"></a>索引(Index)</h5><p><strong>索引是你预期的下一次提交。这就是当你运行<code>git commit</code>时Git看起来的样子。Git将上一次检出到工作目录中的所有文件填充到索引(暂存区),之后你会将其中一些文件替换为新版本,接着通过<code>git commit</code>将它们转换为树来用作新提交。</strong></p><h5 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h5><p><strong>另外两棵树以一种高效但并不直观的方式,将它们的内容存储在<code>.git</code>文件夹中。工作目录会将它们解包为实际的文件以便编辑。你可以把工作目录当做“沙盒”,在你将修改提交到暂存区并记录到历史之前,可以随意更改。</strong></p><h4 id="reset流程图解"><a href="#reset流程图解" class="headerlink" title="==reset流程图解=="></a>==reset流程图解==</h4><p><img src="E:\markdown文件\photoes\image-20210911044957679.png" alt="image-20210911044957679"></p><ul><li><p><code>git reset [--soft | --mixed | --hard] [版本号 | HEAD~n]</code></p><blockquote><ol><li><strong>git reset –soft [版本号|HEAD~n]</strong><br><strong>只回滚提交点,暂存区和工作目录内容不改变</strong><br><img src="E:\markdown文件\photoes\image-20210918201425898.png" alt="image-20210918201425898"></li><li><strong>git reset –mixed [版本号|HEAD~n]  git默认方式</strong><br><strong>回滚提交点和暂存区的内容,工作区内容不变</strong><br><img src="E:\markdown文件\photoes\image-20210918201559211.png" alt="image-20210918201559211"></li><li><strong>git reset –hard [版本号|HEAD~n]</strong><br><strong>提交点、暂存区、工作区全部回滚</strong><br><img src="E:\markdown文件\photoes\image-20210918201912783.png" alt="image-20210918201912783"></li></ol><p>**注意1:HEAD~ HEAD HEAD~1 三者都是等价的,都特指前一个版本</p><pre><code> HEAD~n  n为几,向前回滚几个版本**</code></pre><p><strong>注意2:–hard标记是reset命令==唯一的危险用法==,它也是Git会真正地销毁数据的仅有的几个操作之一。其他任何形式的reset调用都可以轻松撤消,但是–hard选项不能,因为它强制覆盖了工作目录中的文件。</strong></p></blockquote></li><li><p><code>git reset</code>  <strong>另一种用法,后接文件或目录</strong></p><ol><li><p><strong>恢复索引中的文件到某个版本</strong></p><blockquote><p><strong>假设版本库中是文件file.txt的V1版本,HEAD、Index和工作目录都和版本库一致。这时候修改了file.txt文件,并把它(V2版本)加入Index。如下图所示：</strong><br><img src="E:\markdown文件\photoes\image-20210918203417797.png" alt="image-20210918203417797"><br><strong>现在,运行<code>git reset file.txt</code>(这其实是<code>git reset --mixed HEAD file.txt</code>的简写形式),它会让索引看起来像HEAD,所以它本质上只是将file.txt从HEAD复制到索引中。如下图：</strong><br><img src="E:\markdown文件\photoes\image-20210918203540911.png" alt="image-20210918203540911"><br><strong>仔细对比这两幅图,你会发现<code>git reset file.txt</code>有“取消暂存文件”的实际效果。它和git add所做的事相反。这就是为什么git status命令的输出会建议运行此命令来取消暂存一个文件。例如：</strong><br><img src="E:\markdown文件\photoes\image-20210918203811715.png" alt="image-20210918203811715"></p><p><strong>另外,我们可以不让Git从HEAD拉取数据,而是通过具体指定一个提交来拉取该文件的对应版本。我们只需运行类似于<code>git reset eb43bf file.txt</code>的命令即可。依然用图来说明：</strong><br><img src="E:\markdown文件\photoes\image-20210918203923609.png" alt="image-20210918203923609"><br><img src="E:\markdown文件\photoes\image-20210918203953437.png" alt="image-20210918203953437"><strong>以上是版本库、Index和工作目录的状态。现在,执行</strong><code>git reset eb43 file.txt</code><br><img src="E:\markdown文件\photoes\image-20210918204057607.png" alt="image-20210918204057607"></p></blockquote></li><li><p><strong>压缩提交</strong></p><blockquote><p><strong>假设你有一个项目,第一次提交中增加了文件a,第二次提交增加了一个新的文件b并修改了a,第三次提交再次修改了a。</strong><br><strong>那么显然第三次的修改a可以并入第二次的修改a,因为它俩完全是做的一样的事情。</strong></p><p><strong>首先,运行<code>git reset --soft HEAD~2</code>将HEAD分支移动到一个旧一点的提交上(即回滚到第一次的提交):</strong><br><img src="E:\markdown文件\photoes\image-20210918204821001.png" alt="image-20210918204821001"><br><img src="E:\markdown文件\photoes\image-20210918204838215.png" alt="image-20210918204838215"></p><p><strong>然后commit</strong><br><img src="E:\markdown文件\photoes\image-20210918210501674.png" alt="image-20210918210501674"><br><strong>现在你可以查看可到达的历史,即将会推送的历史,现在看起来有个v1版file-a.txt的提交,接着第二个提交将file-a.txt修改成了v3版并增加了file-b.txt。包含v2版本的文件已经不在历史中了。</strong></p></blockquote></li></ol></li></ul><h3 id="reflog-总日志查询"><a href="#reflog-总日志查询" class="headerlink" title="==reflog_总日志查询=="></a>==reflog_总日志查询==</h3><p><strong>有的时候我们使用<code>git reset --hard</code>回退到前几个版本查看日志,哎后几个版本的日志没了？该怎么办？</strong><br><img src="E:\markdown文件\photoes\image-20210904055927110.png" alt="image-20210904055927110"><br><strong>使用<code>git reflog</code>查询commit记录!这样就可以回退回去了,回退之后使用<code>git log</code>版本日志就回来了</strong><br><img src="E:\markdown文件\photoes\image-20210904060121519.png" alt="image-20210904060121519"></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h3 id="Git生成ssh密钥"><a href="#Git生成ssh密钥" class="headerlink" title="Git生成ssh密钥"></a>Git生成ssh密钥</h3><blockquote><p><strong>使用SSH加密方式是Git建议的一种推送,时间上与响应上效率都更高</strong></p></blockquote><ol><li><strong>空白处右键点击Git bath生成SSH公钥与私钥<code>ssh-keygen -t rsa -C "github账户邮箱"</code></strong><br><strong>然后一路回车确定</strong></li><li><strong>密钥保存路径要默认</strong></li><li><strong>密钥自己留着,公钥可以填GitHub里</strong></li><li><strong>在GitHub中配置完后,可以在bath里输入<code>ssh -T git@github.com</code>,有successful就成功了</strong></li></ol><h3 id="clone-克隆操作"><a href="#clone-克隆操作" class="headerlink" title="clone_克隆操作"></a>clone_克隆操作</h3><blockquote><p><strong>第一次拉取本地用git clone,后续更新直接用git pull</strong></p></blockquote><p><img src="E:\markdown文件\photoes\image-20210905131439549.png" alt="image-20210905131439549"></p><p><strong>在指定目录下创建一个子目录,进入其中打开bash,输入</strong><code>git clone github_ssh</code><br><strong>==注意:克隆下来的是所有的内容包括分支,只不过它不显示,但是可以直接切换到分支。而且git clone默认实现了本工作区对远程仓库的绑定,后续使用无需再进行绑定了。==</strong></p><h4 id="Push-推送仓库"><a href="#Push-推送仓库" class="headerlink" title="Push_推送仓库"></a>Push_推送仓库</h4><ol><li><p><strong>在GitHub上创建一个仓库(已有可省略)</strong></p></li><li><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"# git_test"</span> <span class="token operator">&gt;&gt;</span> README.md  <span class="token comment">#添加阅读信息(可省略)</span><span class="token function">git</span> init   <span class="token comment">#初始化本地仓库,已在本地初始化后可不做</span><span class="token function">git</span> <span class="token function">add</span> README.md  <span class="token comment">#添加阅读信息至暂存区(选做)</span><span class="token function">git</span> commit -m <span class="token string">"first commit"</span>  <span class="token comment">#第一次提交本地仓库</span><span class="token function">git</span> branch -M main  <span class="token comment">#改名当前分支为main</span><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:StarLeet/git_test.git <span class="token comment">#本地库绑定远程仓库 并取名origin</span><span class="token function">git</span> push -u origin main <span class="token comment">#进行推送</span><span class="token comment">#-u 表示默认设定提交到origin的main中</span><span class="token comment">#后续可以直接git push(保持默认) 或者 git push origin 分支名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>在第一次push的时候会让你登陆github账户</strong><br><img src="E:\markdown文件\photoes\image-20210905135115524.png" alt="image-20210905135115524"></p></li></ol><h4 id="重定远程仓库"><a href="#重定远程仓库" class="headerlink" title="重定远程仓库"></a>重定远程仓库</h4><p><strong>如果说前边你已经绑定了一个仓库现在想删除它</strong></p><ol><li><strong>工作区打开bash</strong></li><li><code>vim .git/config</code>  /<strong>直接用文本编辑器也可以</strong><br><img src="E:\markdown文件\photoes\image-20210911202701339.png" alt="image-20210911202701339"></li><li><strong>直接删除即可</strong></li></ol><h1 id="branch-分支操作"><a href="#branch-分支操作" class="headerlink" title="branch_分支操作"></a>branch_分支操作</h1><blockquote><p><strong>多人开发时通常不会直接在主干master上进行操作,而是重新开辟新的分支,在新的分支上进行开发调试操作,当项目调试通过时才会将分支的项目代码合并到主干中。</strong><br><strong>主干与分支的关系:犹如原件与副本的关系,副本上出现了问题可以随时丢弃。分支上的变化也不会影响到主干,除非你合并分支</strong></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>git branch</strong></td><td align="center"><strong>查看本地所有的分支(* 代表当前所在分支)</strong></td></tr><tr><td align="center"><strong>git ls-files</strong></td><td align="center"><strong>查看本地仓库的所有文件</strong></td></tr><tr><td align="center"><strong>git checkout 分支名</strong></td><td align="center"><strong>切换分支</strong></td></tr><tr><td align="center"><strong>git checkout -b 新分支名</strong></td><td align="center"><strong>新建一个分支,并切换过去</strong></td></tr><tr><td align="center"><strong>git merge 分支名(可以是主干)</strong></td><td align="center"><strong>将输入分支合并到此分支</strong></td></tr><tr><td align="center"><strong>git branch -d|D 分支名</strong></td><td align="center"><strong>删除/强制删除指定分支</strong></td></tr><tr><td align="center"><strong>git branch -m | -M 旧分支名 新分支名</strong></td><td align="center"><strong>分支重命名,-M是强制重命名</strong></td></tr></tbody></table><h4 id="标准工作流"><a href="#标准工作流" class="headerlink" title="标准工作流"></a>标准工作流</h4><p><img src="E:\markdown文件\photoes\image-20210911201013404.png" alt="image-20210911201013404"></p><h4 id="分支的push与pull操作"><a href="#分支的push与pull操作" class="headerlink" title="分支的push与pull操作"></a>分支的push与pull操作</h4><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>git branch -a</strong></td><td align="center"><strong>查看本地与远程的分支</strong></td></tr><tr><td align="center"><strong>git push origin 分支名</strong></td><td align="center"><strong>将分支推到远端</strong></td></tr><tr><td align="center"><strong>git push origin :分支名</strong></td><td align="center"><strong>删除远端的分支</strong></td></tr><tr><td align="center"><strong>git checkout -b 新命名 origin/远端分支名</strong></td><td align="center"><strong>拉取远端分支到本地</strong></td></tr></tbody></table><h4 id="本地分支冲突"><a href="#本地分支冲突" class="headerlink" title="本地分支冲突"></a>本地分支冲突</h4><blockquote><p><strong>当我们在进行分支操作时,可能会出现这样的情况:</strong><br><strong>master主干上:test1.txt 第六行是1231   leaf01分支上:test1.txt 第六行是010</strong><br><strong>这里进行主干合并leaf01分支时,会产生内容不一致而失败的问题。最主要原因是因为主干与分支的相同行内容不合。这个称为分支冲突</strong></p></blockquote><h4 id="多人协同冲突"><a href="#多人协同冲突" class="headerlink" title="多人协同冲突"></a>多人协同冲突</h4><blockquote><p><strong>多个本地仓库向github上传的内容不一样会导致</strong><br><strong>典型报错信息:</strong></p><p><img src="E:\markdown文件\photoes\image-20210911041920638.png" alt="image-20210911041920638"></p></blockquote><p><strong>解决方式:push前先从远端拉取一下内容<code>git pull</code>,这样可以解决80%的冲突</strong></p><h1 id="tag标签管理"><a href="#tag标签管理" class="headerlink" title="tag标签管理"></a>tag标签管理</h1><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>git tag</strong></td><td align="center"><strong>查看所有标签</strong></td></tr><tr><td align="center"><strong>git tag 标签名</strong></td><td align="center"><strong>新建本地标签 默认为HEAD</strong></td></tr><tr><td align="center"><strong>git tag -a 标签名 -m ‘描述信息’</strong></td><td align="center"><strong>-a表示有标签,新建本地标签并指定描述信息</strong></td></tr><tr><td align="center"><strong>git tag -d 标签名</strong></td><td align="center"><strong>删除一个本地标签</strong></td></tr><tr><td align="center"><strong>git push origin 标签名</strong></td><td align="center"><strong>推送一个本地标签到远端</strong></td></tr><tr><td align="center"><strong>git push origin –tags</strong></td><td align="center"><strong>推送所有本地标签</strong></td></tr><tr><td align="center"><strong>git push origin :refs/tags/标签名</strong></td><td align="center"><strong>删除一个远端标签</strong></td></tr></tbody></table><h2 id="补充-工作流程"><a href="#补充-工作流程" class="headerlink" title="补充:工作流程"></a>补充:工作流程</h2><p><strong>公司新上任拉取代码</strong></p><blockquote><ol><li><strong>git clone 远程仓库地址 (自带git remote add origin 仓库DNS域名)</strong></li><li><strong>git checkout 分支 (切换分支)</strong></li><li><strong>git clone一般仅操作一次,后续用的pull,只拉取变动的提交</strong></li></ol></blockquote><p><strong>在公司开发</strong></p><blockquote><ol><li><strong>git checkout dev (切换到开发分支)</strong></li><li><strong>git merge master(把主干并入分支dev 仅一次)</strong></li><li><strong>修改代码</strong></li><li><strong>提交代码</strong></li><li><strong>git add .</strong></li><li><strong>git commit -m ‘说明’</strong></li><li><strong>git push origin dev</strong></li></ol></blockquote><p><strong>回到家中继续写代码</strong></p><blockquote><ol><li><strong>git checkout dev</strong></li><li><strong>拉取代码 git pull origin dev</strong></li><li><strong>继续开发,相同的提交步骤</strong></li></ol></blockquote><h1 id="rebase-变基"><a href="#rebase-变基" class="headerlink" title="rebase(变基)"></a>rebase(变基)</h1><p><strong>变基的作用:使Git记录变得简洁,即合并几次提交记录</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#方式一</span><span class="token function">git</span> rebase -i 版本号 <span class="token comment">#表示合并从该版本号到目前版本的记录</span><span class="token comment">#方式二</span><span class="token function">git</span> rebase -i HEAD~3 <span class="token comment">#表示合并最近三次的提交记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:尽量不要合并push到远程仓库的记录</strong></p><p><strong>使用情景一:</strong></p><blockquote><ol><li><strong>切换到支线dev   <code>git checkout dev</code></strong></li><li><strong>在分支上提交新的记录</strong> <code>git commit -m 'xxx'</code></li><li><strong>把刚才提交的记录变基到主干      <code>git rebase master</code></strong></li><li><strong>切换到master   <code>git checkout master</code></strong></li><li><strong>合并分支dev     <code>git merge dev</code></strong></li></ol><p><strong>如此操作下来,合并的日志将不在有分叉,而是直接跟主干的日志是一样的</strong><br><img src="E:\markdown文件\photoes\image-20210913104007537.png" alt="image-20210913104007537"></p><p><img src="E:\markdown文件\photoes\image-20210913100455701.png" alt="image-20210913100455701"></p></blockquote><p><strong>使用场景二:</strong><br><img src="E:\markdown文件\photoes\image-20210913102434863.png" alt="image-20210913102434863"><br><img src="E:\markdown文件\photoes\image-20210913103936505.png" alt="image-20210913103936505"></p><p><strong>如果说你想让支线日志归并到主线而不产生分叉:C1&lt;——C2&lt;——C3&lt;——C4</strong></p><blockquote><p><strong>我们将代码从远端仓库拉回本地的时候,如果发生冲突是会产生分叉的日志。要想不产生分叉日志,使其更加地简洁。我们就不能再使用pull(fetch + merge)</strong></p><ol><li><strong>git fetch origin dev</strong></li><li><strong>git rebase origin/dev</strong></li></ol></blockquote><h4 id="rebase碰上冲突"><a href="#rebase碰上冲突" class="headerlink" title="rebase碰上冲突"></a>rebase碰上冲突</h4><p><img src="E:\markdown文件\photoes\image-20210913100209552.png" alt="image-20210913100209552"></p><p><strong>如果我们使用git rebase碰上了冲突,解决方式是:</strong></p><ol><li><strong>手动解决冲突区块</strong></li><li><strong>根据提示执行<code>git add .</code></strong></li><li><code>git rebase --continue</code><br><img src="E:\markdown文件\photoes\image-20210913100347673.png" alt="image-20210913100347673"></li></ol><h2 id="前面总结"><a href="#前面总结" class="headerlink" title="==前面总结=="></a>==前面总结==</h2><ul><li><p><strong>绑定远程仓库</strong></p><blockquote><p><strong>git remote add origin 链接</strong></p></blockquote></li><li><p><strong>推送到远程仓库</strong></p><blockquote><p><strong>git push origin 分支名</strong></p></blockquote></li><li><p><strong>下载代码</strong></p><blockquote><p><strong>git clone 链接</strong></p></blockquote></li><li><p><strong>拉取代码</strong></p><blockquote><p><strong>git pull origin 分支名  &lt;=&gt; git fetch origin 分支名</strong></p><pre><code>                       **git merge origin 分支名**</code></pre></blockquote></li><li><p><strong>保持代码提交简洁(变基)</strong></p><blockquote><p><strong>git rebase 分支名</strong></p></blockquote></li><li><p><strong>log日志图形展示</strong></p><blockquote><p><strong>git log –graph [–pretty=format:“%h %s”]</strong></p></blockquote></li></ul><h2 id="多人协同开发gitflow"><a href="#多人协同开发gitflow" class="headerlink" title="多人协同开发gitflow"></a>多人协同开发gitflow</h2><p><img src="E:\markdown文件\photoes\image-20210913144251687.png" alt="image-20210913144251687"></p><p><strong>从主干上开辟dev分支(开发部门总项目人把关),从dev分支再开辟各小组分支;在自己分支上做完开发后,由总项目人确定无误后,合并到dev分支上同时开辟的新的分支release(用于测试并修复bug),无误后合并到master主干。</strong></p><h2 id="tag标签用法"><a href="#tag标签用法" class="headerlink" title="tag标签用法"></a>tag标签用法</h2><p><code>git tag -a 标签名 -m '描述信息'</code> <strong>给当前提交的(HEAD指针所指的)日志打上标签,比如:release1.0</strong></p><p><strong>打完标签后,推送到远程仓库(github):</strong><br><strong><code>git push origin --tags</code></strong></p><p><strong>tag相当于是给日志那个冗长的hash值取了个昵称</strong></p><h2 id="给开源项目贡献代码"><a href="#给开源项目贡献代码" class="headerlink" title="给开源项目贡献代码"></a>给开源项目贡献代码</h2><ol><li><strong>fork源代码:将别人源代码拷贝到我自己的远程仓库</strong></li><li><strong>pull拉取代码到本地进行二次开发</strong></li><li><strong>push到远程仓库</strong></li><li><strong>给源代码作者提交 修复bug的申请(pull request)</strong></li></ol><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><p><strong>如果有不需要git管理跟踪的文件,可以加在.gitignore文件中</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>first article</title>
      <link href="/posts/64c6e1a6.html"/>
      <url>/posts/64c6e1a6.html</url>
      
        <content type="html"><![CDATA[<p>下边是java噢~</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token comment">//1.客户端直接实例化一个Socket</span>        <span class="token class-name">Socket</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端 socket返回 ="</span> <span class="token operator">+</span> socket<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">OutputStream</span> outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>socket<span class="token punctuation">.</span><span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置结束标记</span>        <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> readLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>readLen <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>readLen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端退出"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone xxxxx<span class="token function">git</span> reset --hard HEAD~n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> <span class="token class-name">Cat</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name    <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Syetem</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_CLOCK_T_DEFINED</span></span><span class="token keyword">typedef</span> <span class="token keyword">long</span> clock_t<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">_CLOCK_T_DEFINED</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span> <span class="token keyword">typedef</span> <span class="token keyword">int</span> ElementType<span class="token punctuation">;</span>        <span class="token comment">//    定义数据类型,可根据需要进行其他类型定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    ElementType  Element<span class="token punctuation">;</span>        <span class="token comment">//    数据域，存放数据</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> Next<span class="token punctuation">;</span>        <span class="token comment">//    指向下一个链表节点</span><span class="token punctuation">}</span>Node<span class="token punctuation">,</span><span class="token operator">*</span>List<span class="token punctuation">;</span>       <span class="token comment">//List   ~ Node *  </span><span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> <span class="token operator">*</span>phead <span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token operator">*</span>phead <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>phead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"头节点分配失败!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token punctuation">(</span><span class="token operator">*</span>phead<span class="token punctuation">)</span><span class="token operator">-&gt;</span>Next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">AddItemInHead</span><span class="token punctuation">(</span>List pHead<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">,</span>Node <span class="token operator">*</span> <span class="token operator">*</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>         List pNew <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成新节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pNew <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"新节点分配失败，程序终止！ \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pNew<span class="token operator">-&gt;</span>Element<span class="token operator">=</span>val<span class="token punctuation">;</span>    pNew<span class="token operator">-&gt;</span>Next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pHead<span class="token operator">-&gt;</span>Next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pHead<span class="token operator">-&gt;</span>Next <span class="token operator">=</span> pNew<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token operator">*</span>tail<span class="token punctuation">)</span><span class="token operator">-&gt;</span>Next <span class="token operator">=</span> pNew<span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token operator">*</span>tail <span class="token operator">=</span> pNew<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">AddItemInTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span>List <span class="token operator">*</span>tail<span class="token punctuation">)</span><span class="token punctuation">{</span>         List pNew <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成新节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pNew <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"新节点分配失败，程序终止！ \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    pNew<span class="token operator">-&gt;</span>Element<span class="token operator">=</span>val<span class="token punctuation">;</span>    pNew<span class="token operator">-&gt;</span>Next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span><span class="token operator">*</span>tail<span class="token punctuation">)</span><span class="token operator">-&gt;</span>Next <span class="token operator">=</span> pNew<span class="token punctuation">;</span>    <span class="token operator">*</span>tail <span class="token operator">=</span> pNew<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">Showlist</span><span class="token punctuation">(</span>List pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    pHead<span class="token operator">=</span>pHead<span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span> <span class="token comment">//跳过头结点输出</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pHead<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>pHead<span class="token operator">-&gt;</span>Element<span class="token punctuation">)</span><span class="token punctuation">;</span>    pHead<span class="token operator">=</span>pHead<span class="token operator">-&gt;</span>Next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment">//    主函数</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">*</span> L<span class="token punctuation">;</span>    Node <span class="token operator">*</span> tail<span class="token punctuation">;</span>         <span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>               clock_t start<span class="token punctuation">,</span>finish<span class="token punctuation">;</span>    <span class="token keyword">double</span> totaltime<span class="token punctuation">;</span>    start<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">AddItemInHead</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token function">AddItemInTail</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>         finish<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    totaltime<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>finish<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span>CLOCKS_PER_SEC<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n向链表添加数据时间为%f秒！\n"</span><span class="token punctuation">,</span>totaltime<span class="token punctuation">)</span><span class="token punctuation">;</span>     start<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">AddItemInTail</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//Showlist(L);</span>    finish<span class="token operator">=</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    totaltime<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>finish<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token operator">/</span>CLOCKS_PER_SEC<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n输出数据时间为%f秒！\n"</span><span class="token punctuation">,</span>totaltime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown快速入门小技巧(hexo博客文章--格式用法)</title>
      <link href="/posts/15546.html"/>
      <url>/posts/15546.html</url>
      
        <content type="html"><![CDATA[<p>相遇皆是缘分</p><h1 id="Markdown-的快速入门-后缀是-md"><a href="#Markdown-的快速入门-后缀是-md" class="headerlink" title="Markdown 的快速入门(后缀是  .md)"></a>Markdown 的快速入门(后缀是  .md)</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html">ctrl+shift+1 大纲显示ctrl+/ 源代码显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">​```<span class="token function">java</span><span class="token punctuation">(</span>html等等<span class="token punctuation">)</span>   会自动提示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html">#标题1 （大）##标题2###标题3####标题4 （小）以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//加粗</span><span class="token operator">*</span><span class="token operator">*</span>加粗<span class="token operator">*</span><span class="token operator">*</span><span class="token comment">//代码高亮显示</span><span class="token operator">==</span>高亮<span class="token operator">==</span><span class="token comment">//删除线</span><span class="token operator">~</span><span class="token operator">~</span>删除线<span class="token operator">~</span><span class="token operator">~</span><span class="token comment">//斜体</span>  <span class="token operator">*</span>斜体内容<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//引用语法</span><span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：泽</p><blockquote><p>作者：泽</p><blockquote><p>作者：泽</p></blockquote></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//分割线</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//在线图片与本地图片</span><span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（<span class="token operator">/</span>image<span class="token operator">/</span>me<span class="token punctuation">.</span>png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3252521864,872614242&amp;fm=26&amp;gp=0.jpg" alt="img"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//超链接语法</span><span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>gihub<span class="token punctuation">.</span>com<span class="token operator">/</span>yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://music.163.com/#/song?id=28892408&amp;market=baiduqk">我的天空</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//无需列表</span><span class="token operator">-</span> 目录<span class="token number">1</span>  <span class="token operator">-</span>后加空格<span class="token operator">-</span> 目录<span class="token number">2</span><span class="token operator">-</span> 目录<span class="token number">3</span><span class="token comment">//有序列表</span>  <span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">.</span> <span class="token operator">+</span>名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="center">姓名</th><th align="center">数字</th><th align="center">语文</th></tr></thead><tbody><tr><td align="center">小王</td><td align="center">85</td><td align="center">21</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
